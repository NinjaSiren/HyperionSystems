/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package data.scripts.world;

import com.fs.starfarer.api.Global;
import com.fs.starfarer.api.campaign.PlanetAPI;
import com.fs.starfarer.api.campaign.SectorEntityToken;
import com.fs.starfarer.api.campaign.StarSystemAPI;
import com.fs.starfarer.api.campaign.econ.MarketAPI;
import com.fs.starfarer.api.campaign.econ.MarketConditionAPI;
import com.fs.starfarer.api.util.Misc;
import java.io.IOException;
import java.util.List;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.json.JSONArray;
import org.json.JSONException;

/**
 *
 * @author NinjaSiren
 */
public class HS_AutoGeneratePlanets {
    
    // Roll the dice, orbit radius
    private float rand_orbit(float minOR, float maxOR) {
        Random rand = new Random();
        return minOR + rand.nextFloat() * (maxOR - minOR);
    }
    
    // Roll the dice, orbital period
    private float rand_period(float minOP, float maxOP) {
        Random rand = new Random();
        return minOP + rand.nextFloat() * (maxOP - minOP);
    }
    
    // Roll the dice, orbital angle
    private int rand_angle() {
        Random rand = new Random();
        int minOA = 0;
        int maxOA = 360;
        return minOA + rand.nextInt(maxOA - minOA + 1);
    }
    
    // Autogenerates random planets
    public HS_AutoGeneratePlanets(StarSystemAPI system, PlanetAPI star, SectorEntityToken center, 
            PlanetAPI[] planets, int planetAmount, PlanetAPI[] stars, int starsAmount, float orbit_radius, 
            float orbit_period, float minOrbitRadius, float maxOrbitRadius, float minOrbitPeriod, 
            float maxOrbitPeriod, boolean enableFactions, SectorEntityToken[] station, MarketAPI[] markets, 
            String factionA, String factionB, double factions) {    
        int counter = 0;
        List <MarketConditionAPI> condition_list;    
        
        if(center == null && star != null) {
            do {
                if(counter >= planetAmount) break;

                // Sets the current planet type
                String planetType = new HS_PlanetType().planetType(stars, starsAmount, planets, planetAmount, 
                        orbit_radius);

                // Sets the current planet size
                int planetSize = new HS_PlanetSize().planetSize(planetType);

                // Initiates the addition of the planet
                planets[counter] = system.addPlanet(
                        "hs_planet_" + counter, // Unique id for this planet (or null to have it be autogenerated)
                        star, // What the planet orbits (orbit is always circular)
                        pNameGen(), // Name
                        planetType, // Planet type id in planets.json
                        rand_angle(), // Starting angle in orbit, i.e. 0 = to the right of the star
                        planetSize, // Planet radius, pixels at default zoom
                        orbit_radius, // Orbit radius, pixels at default zoom
                        orbit_period); // Days it takes to complete an orbit. 1 day = 10 seconds.
                
                // Adds Rings and Magnetic Effects
                new HS_AddPlanetRings(system, planets[counter], star);

                // Adds planet conditions
                Misc.initConditionMarket(planets[counter]);
                new HS_PlanetCondition(planetType, star, stars, starsAmount, orbit_radius, planets, counter, planetSize);
                condition_list = planets[counter].getMarket().getConditions();

                // Adds the previous orbit radius with the current radius then adds a random number orbit
                orbit_radius = orbit_radius + rand_orbit(minOrbitRadius, maxOrbitRadius);

                /* 
                 * Adds the previous orbit period radius with the current radius then adds a random number 
                 * orbit period
                 */
                orbit_period = orbit_period + (orbit_period * rand_period(minOrbitPeriod, maxOrbitPeriod));

                // Adds factions, if habitable or hazards are less than 200%
                if(enableFactions) {
                    if(planetType.equals(new Planet().ARID) ||
                            planetType.equals(new Planet().DESERT_A) ||
                            planetType.equals(new Planet().DESERT_B) ||
                            planetType.equals(new Planet().JUNGLE) ||
                            planetType.equals(new Planet().OCEAN) ||
                            planetType.equals(new Planet().TERRAN) ||
                            planetType.equals(new Planet().TERRAN_ECCENTRIC) ||
                            planetType.equals(new Planet().TUNDRA) ||
                            planetType.equals(new Planet().US_ALKALI) ||
                            planetType.equals(new Planet().US_ARID) ||
                            planetType.equals(new Planet().US_ARID_LIFELESS) ||
                            planetType.equals(new Planet().US_AURIC) ||
                            planetType.equals(new Planet().US_AURIC_CLOUDY) ||
                            planetType.equals(new Planet().US_CRIMSON) ||
                            planetType.equals(new Planet().US_DESERT_A) ||
                            planetType.equals(new Planet().US_DESERT_B) ||
                            planetType.equals(new Planet().US_DESERT_C) ||
                            planetType.equals(new Planet().US_JUNGLE) ||
                            planetType.equals(new Planet().US_LIFELESS) ||
                            planetType.equals(new Planet().US_MAGNETIC) ||
                            planetType.equals(new Planet().US_METHANE) ||
                            planetType.equals(new Planet().US_OCEAN_A) ||
                            planetType.equals(new Planet().US_OCEAN_B) ||
                            planetType.equals(new Planet().US_RED) ||
                            planetType.equals(new Planet().US_RED_WIND) ||
                            planetType.equals(new Planet().US_STORM) ||
                            planetType.equals(new Planet().US_TERRAN)) {
                        new HS_AddFactions(
                                station[counter], // SectorEntityToken, usually Nexrelin stations
                                planets[counter], // PlanetAPI array
                                factionA, // Faction A, to be generated
                                factionB, // Faction B, to be generated
                                markets[counter], // MarketAPI array
                                planetAmount, // System planet count
                                condition_list, // Planet condition list
                                factions / 100); // The percentage of factionA appearing vs factionB on the system
                    } else if (planets[counter].getMarket().getHazardValue() < 2) {
                        new HS_AddFactions(
                                station[counter], // SectorEntityToken, usually Nexrelin stations
                                planets[counter], // PlanetAPI array
                                factionA, // Faction A, to be generated
                                factionB, // Faction B, to be generated
                                markets[counter], // MarketAPI array
                                planetAmount, // System planet count
                                condition_list, // Planet condition list
                                factions / 100); // The percentage of factionA appearing vs factionB on the system
                    }
                }
                
                // Adds stations
                new HS_AddStation(system, star, planets[counter]);
                
                counter++;
            } while(counter < planetAmount + 1);
        } else if(center != null && star != null) {
            do {
                if(counter >= planetAmount) break;

                // Sets the current planet type
                String planetType = new HS_PlanetType().planetType(stars, starsAmount, planets, planetAmount, 
                        orbit_radius);

                // Sets the current planet size
                int planetSize = new HS_PlanetSize().planetSize(planetType);

                // Initiates the addition of the planet
                planets[counter] = system.addPlanet(
                        "hs_planet_" + counter, // Unique id for this planet (or null to have it be autogenerated)
                        center, // What the planet orbits (orbit is always circular)
                        pNameGen(), // Name
                        planetType, // Planet type id in planets.json
                        rand_angle(), // Starting angle in orbit, i.e. 0 = to the right of the star
                        planetSize, // Planet radius, pixels at default zoom
                        orbit_radius, // Orbit radius, pixels at default zoom
                        orbit_period); // Days it takes to complete an orbit. 1 day = 10 seconds.

                // Adds Rings and Magnetic Effects
                new HS_AddPlanetRings(system, planets[counter], star);                
                
                // Adds planet conditions
                Misc.initConditionMarket(planets[counter]);
                new HS_PlanetCondition(planetType, star, stars, starsAmount, orbit_radius, planets, counter, planetSize);
                condition_list = planets[counter].getMarket().getConditions();

                // Adds the previous orbit radius with the current radius then adds a random number orbit
                orbit_radius = orbit_radius + rand_orbit(minOrbitRadius, maxOrbitRadius);

                /* 
                 * Adds the previous orbit period radius with the current radius then adds a random number 
                 * orbit period
                 */
                orbit_period = orbit_period + (orbit_period * rand_period(minOrbitPeriod, maxOrbitPeriod));

                // Adds factions, if habitable or hazards are less than 200%
                if(enableFactions) {
                    if(planetType.equals(new Planet().ARID) ||
                            planetType.equals(new Planet().DESERT_A) ||
                            planetType.equals(new Planet().DESERT_B) ||
                            planetType.equals(new Planet().JUNGLE) ||
                            planetType.equals(new Planet().OCEAN) ||
                            planetType.equals(new Planet().TERRAN) ||
                            planetType.equals(new Planet().TERRAN_ECCENTRIC) ||
                            planetType.equals(new Planet().TUNDRA) ||
                            planetType.equals(new Planet().US_ALKALI) ||
                            planetType.equals(new Planet().US_ARID) ||
                            planetType.equals(new Planet().US_ARID_LIFELESS) ||
                            planetType.equals(new Planet().US_AURIC) ||
                            planetType.equals(new Planet().US_AURIC_CLOUDY) ||
                            planetType.equals(new Planet().US_CRIMSON) ||
                            planetType.equals(new Planet().US_DESERT_A) ||
                            planetType.equals(new Planet().US_DESERT_B) ||
                            planetType.equals(new Planet().US_DESERT_C) ||
                            planetType.equals(new Planet().US_JUNGLE) ||
                            planetType.equals(new Planet().US_LIFELESS) ||
                            planetType.equals(new Planet().US_MAGNETIC) ||
                            planetType.equals(new Planet().US_METHANE) ||
                            planetType.equals(new Planet().US_OCEAN_A) ||
                            planetType.equals(new Planet().US_OCEAN_B) ||
                            planetType.equals(new Planet().US_RED) ||
                            planetType.equals(new Planet().US_RED_WIND) ||
                            planetType.equals(new Planet().US_STORM) ||
                            planetType.equals(new Planet().US_TERRAN)) {
                        new HS_AddFactions(
                                station[counter], // SectorEntityToken, usually Nexrelin stations
                                planets[counter], // PlanetAPI array
                                factionA, // Faction A, to be generated
                                factionB, // Faction B, to be generated
                                markets[counter], // MarketAPI array
                                planetAmount, // System planet count
                                condition_list, // Planet condition list
                                factions / 100); // The percentage of factionA appearing vs factionB on the system
                    } else if (planets[counter].getMarket().getHazardValue() < 2) {
                        new HS_AddFactions(
                                station[counter], // SectorEntityToken, usually Nexrelin stations
                                planets[counter], // PlanetAPI array
                                factionA, // Faction A, to be generated
                                factionB, // Faction B, to be generated
                                markets[counter], // MarketAPI array
                                planetAmount, // System planet count
                                condition_list, // Planet condition list
                                factions / 100); // The percentage of factionA appearing vs factionB on the system
                    }
                }
                counter++;
            } while(counter < planetAmount + 1);
        }
    }
    
    // Roll the dice, system background
    private int rand() {
        Random rand = new Random();
        final int max = 739;
        final int min = 0;
        return min + rand.nextInt(max - min + 1);
    }
    
    private String pNameGen() {
        JSONArray planetNames;
        String planetName;
        
        try {
            // Gets the data from the settings.json
            planetNames =  Global.getSettings().loadJSON("data/strings/ship_names.json")
                    .getJSONArray("GREEK");
            if(planetNames != null) {
                try {
                    planetName = planetNames.getString(rand());
                    if(planetName != null) {
                        return planetName;
                    } 
                } catch (JSONException ex) {
                    Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);
                }
            }
        } catch (IOException | JSONException ex) {
            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }
}
