package data.scripts.world.systems;

import com.fs.starfarer.api.Global;
import com.fs.starfarer.api.campaign.JumpPointAPI;
import com.fs.starfarer.api.campaign.OrbitAPI;
import com.fs.starfarer.api.campaign.PlanetAPI;
import com.fs.starfarer.api.campaign.SectorAPI;
import com.fs.starfarer.api.campaign.SectorEntityToken;
import com.fs.starfarer.api.campaign.StarSystemAPI;
import com.fs.starfarer.api.campaign.econ.MarketAPI;
import com.fs.starfarer.api.impl.campaign.ids.Industries;
import com.fs.starfarer.api.impl.campaign.ids.StarTypes;
import com.fs.starfarer.api.impl.campaign.ids.Terrain;
import com.fs.starfarer.api.impl.campaign.procgen.NebulaEditor;
import com.fs.starfarer.api.impl.campaign.procgen.ProcgenUsedNames;
import com.fs.starfarer.api.impl.campaign.procgen.StarAge;
import com.fs.starfarer.api.impl.campaign.terrain.HyperspaceTerrainPlugin;
import com.fs.starfarer.api.impl.campaign.terrain.MagneticFieldTerrainPlugin;
import com.fs.starfarer.api.util.Misc;
import data.scripts.HyperionRandomizer;
import data.scripts.world.HS_AutoGeneratePlanets;
import data.scripts.world.Star;
import java.awt.Color;
import java.util.Random;

/**
 *
 * @author NinjaSiren
 */
public class HS_Phia {
    
    // Roll the dice
    private double rand() {
        Random rand = new Random();
        final double max = 1.0;
        final double min = 0.0;
        return min + rand.nextDouble() * (max - min);
    }
    
    // Roll the dice for planet tariff
    private float tariff() {
        Random rand = new Random();
        final float max = 0.12f;
        final float min = 0.0f;
        return min + rand.nextFloat() * (max - min);
    }
    
    // Roll the dice
    private double rand2() {
        Random rand = new Random();
        final double max = 1.0;
        final double min = 0.0;
        return min + rand.nextDouble() * (max - min);
    }
    
    public void generate(SectorAPI sector) {
        
        // Checks if Unknown Skies is enabled
        boolean isUS = Global.getSettings().getModManager().isModEnabled("US");
        
        // Add star system
        StarSystemAPI system = sector.createStarSystem("Phia");
        system.getLocation().set(-25600, -20500);
        system.setBackgroundTextureFilename("graphics/backgrounds/background3.jpg");
        ProcgenUsedNames.notifyUsed("Phia");
        ProcgenUsedNames.notifyUsed("Kria");   
        
        // Add stars
        PlanetAPI phia = system.initStar(
                    "phia", // unique id for this star
                    StarTypes.RED_SUPERGIANT,  // id in planets.json
                    1650,           // radius (in pixels at default zoom)
                    2450,            // corona radius, from star edge
                    2.5f,             // solar wind burn level
                    0.7f,           // flare probability
                    2.2f);          // CR loss multipiers
        phia.setCustomDescriptionId("hs_star_phia"); 
        
        PlanetAPI kria;
        if(isUS) {
            kria = system.addPlanet(
                    "kria", //Unique id for this planet (or null to have it be autogenerated)
                    phia, //What the planet orbits (planets[counter_2].getCircularOrbitRadius() is always circular)
                    "Kria", //Name
                    StarTypes.WHITE_DWARF, //Planet type id in planets.json
                    0, //Starting angle in planets[counter_2].getCircularOrbitRadius(), i.e. 0 = to the right of the star
                    550, //Planet radius, pixels at default zoom
                    0, //Orbit radius, pixels at default zoom
                    0); //Days it takes to complete an planets[counter_2].getCircularOrbitRadius(). 1 day = 10 seconds.
        } else {
            kria = system.addPlanet(
                    "kria", //Unique id for this planet (or null to have it be autogenerated)
                    phia, //What the planet orbits (planets[counter_2].getCircularOrbitRadius() is always circular)
                    "Kria", //Name
                    new Star().WHITE_DWARF_US, //Planet type id in planets.json
                    0, //Starting angle in planets[counter_2].getCircularOrbitRadius(), i.e. 0 = to the right of the star
                    550, //Planet radius, pixels at default zoom
                    0, //Orbit radius, pixels at default zoom
                    0); //Days it takes to complete an planets[counter_2].getCircularOrbitRadius(). 1 day = 10 seconds.
        }
        kria.setCustomDescriptionId("hs_star_kria");
        
        // Adds a corona for Kria
        system.addCorona(
                kria, // ID or name of the fake star
                Terrain.CORONA, // What terrain type is it, terrain.json
                500, // Additional radius of the terrain type
                1.25f, // The wind burn level of the terrain type
                0.15f, // The flare probability of the terrain type
                1.3f); // The CR loss multiplier of the terrain type 

        // Sets whole system lighting color (R, G, B)
        system.setLightColor(new Color(245, 123, 113));

        // Adds magnetic field effect around the star
        SectorEntityToken kria_mfield1 = system.addTerrain(
                Terrain.MAGNETIC_FIELD,
                new MagneticFieldTerrainPlugin.MagneticFieldParams(
                300f, // terrain effect band width
                600, // terrain effect middle radius
                kria, // entity that it's around
                700f, // visual band start
                1050f, // visual band end
                new Color(50, 30, 100, 30), // base color
                0.3f, // probability to spawn aurora sequence, checked once/day when no aurora in progress
                new Color(50, 20, 110, 130),
                new Color(150, 30, 120, 150),
                new Color(200, 50, 130, 190),
                new Color(250, 70, 150, 240),
                new Color(200, 80, 130, 255),
                new Color(75, 0, 160),
                new Color(127, 0, 255)));
        kria_mfield1.setCircularOrbit(kria, 0, 0, 120); 
        
        // Autogenerate planets
        int planetAmount = 6; // Amount of planets you want
        int starsAmount = 1; // The amount of stars you manually added
        
        // Minimum orbit radius, lowest a planet can go
        float baseOrbitRadius = (float) (phia.getRadius() * 2); // Base orbit radius
        float baseOrbitPeriod = 60; // Minimum orbital period, lowest a planet can go
        float minOrbitRadius = 1250; // Minimum orbit radius to be added to the baseOrbitRadius
        float maxOrbitRadius = 2250; // Maximum orbit radius to be added to the baseOrbitRadius
        float minOrbitPeriod = 0.2f; // Minimum orbital period to be added to the baseOrbitRadius
        float maxOrbitPeriod = 0.7f; // Maximum orbital period to be added to the baseOrbitPeriod
        PlanetAPI[] planets = new PlanetAPI[planetAmount + 1]; // Initiates the Planet array
        planets[6] = kria; // Sets Kria as a fake star
        PlanetAPI[] stars = new PlanetAPI[starsAmount]; // Initiates the Star array
        stars[0] = phia; // Sets the final values of the Star array
        
        // Automatically generates random planets in the system based on the values you added
        new HS_AutoGeneratePlanets(system, phia, planets, planetAmount, stars, starsAmount, baseOrbitRadius, 
                baseOrbitPeriod, minOrbitRadius, maxOrbitRadius, minOrbitPeriod, maxOrbitPeriod);
        
        // Kria orbits outside Phia
        kria.setCircularOrbitWithSpin(
                phia, // ID or name of the parent body
                180, // Object facing angle
                (float) (phia.getRadius() * 1.45), // Object orbital radius
                40, // Object orbital period
                5, // Object minimum spin
                7.5f); // Object maximum spin
        
        // Other system automation stuff
        system.setStar(phia);
        system.setSecondary(kria);
        system.setAge(StarAge.AVERAGE);
        system.setHasSystemwideNebula(true);
        system.setProcgen(true);
        Misc.setAllPlanetsSurveyed(system);
        Misc.setAllPlanetsKnown(system);
        
        // Jump points, Habitable
        int jp_counter = 0;
        do {
            if(jp_counter < 0 || jp_counter >= planetAmount) break;
            else if(planets[jp_counter].getTags().contains("hab")) {
                JumpPointAPI planet_jp = Global.getFactory().createJumpPoint(planets[jp_counter].getName() + "_jp", planets[jp_counter].getName() + " Inner Jump Point");
                OrbitAPI orbit_1 = Global.getFactory().createCircularOrbit(phia, 
                        90, 
                        planets[jp_counter].getCircularOrbitRadius(), 
                        157);
                planet_jp.setOrbit(orbit_1);
                planet_jp.setRelatedPlanet(planets[jp_counter]);
                planet_jp.setStandardWormholeToHyperspaceVisual();
                system.addEntity(planet_jp);
            }
            jp_counter++;
        } while(jp_counter < planetAmount);
        
        // Jump points, inner
        float orbitJP1 = planets[1].getCircularOrbitRadius() - ((planets[0].getCircularOrbitRadius() - planets[1].getCircularOrbitRadius()));
        float orbitJP2 = planets[4].getCircularOrbitRadius() - ((planets[4].getCircularOrbitRadius() - planets[3].getCircularOrbitRadius()));
        
        JumpPointAPI inner_jp = Global.getFactory().createJumpPoint(
                "inner_jp", "Phia Inner Jump Point");
        OrbitAPI orbit_1 = Global.getFactory().createCircularOrbit(phia, 126, orbitJP1, 157);
        inner_jp.setOrbit(orbit_1);
        inner_jp.setStandardWormholeToHyperspaceVisual();
        system.addEntity(inner_jp);
        
        // Jump points, outer
        JumpPointAPI outer_jp = Global.getFactory().createJumpPoint(
                "outer_jp", "Phia Inner Jump Point");
        OrbitAPI orbit_2 = Global.getFactory().createCircularOrbit(phia, 252, orbitJP2, 368);
        outer_jp.setOrbit(orbit_2);
        outer_jp.setStandardWormholeToHyperspaceVisual();
        system.addEntity(outer_jp);
        
        // Autogenerated jump points
        system.autogenerateHyperspaceJumpPoints(true, true, false);
                
        // Cleaning the hyperspace
        HyperspaceTerrainPlugin plugin =
                (HyperspaceTerrainPlugin) Misc.getHyperspaceTerrain().getPlugin();
        NebulaEditor editor = new NebulaEditor(plugin);
        float minRadius = plugin.getTileSize() * 2f;

        float radius = system.getMaxRadiusInHyperspace();
        editor.clearArc(system.getLocation().x, system.getLocation().y, 0,
                radius + minRadius * 0.5f, 0, 360f);
        editor.clearArc(system.getLocation().x, system.getLocation().y, 0,
                radius + minRadius, 0, 360f, 0.25f);
    }
    
    // Extra industry randomizer
    private String cryoIndustries() {
        double random = rand();
        
        if(random <= 0.8) {
            return null;
        } else if(random > 0.8 && random >= 0.9) {
            return Industries.CRYOSANCTUM;
        } else {
            return "cryorevival";
        }
    }
    
    // Ship Hull Randomizers
    private String HSSship_id() {
        int number = new HyperionRandomizer(11).value;
        String ship_id;

        //Ship Randomizers
        switch (number) {
            case 0:
                return ship_id = "HS_Orionis";
            case 1:
                return ship_id = "HS_Naos";
            case 2:
                return ship_id = "HS_Betelgeuse";
            case 3:
                return ship_id = "HS_Arcturus";
            case 4:
                return ship_id = "HS_Icarus";
            case 5:
                return ship_id = "HS_Alycone";
            case 6:
                return ship_id = "HS_Bellatrix";
            case 7:
                return ship_id = "HS_Carinae";
            case 8:
                return ship_id = "HS_Sirius";
            case 9:
                return ship_id = "HS_Eridani";
            case 10:
                return ship_id = "HS_Cassiopeia";
            case 11:
                return ship_id = "HS_Perseus";
            default:
                break;
        }
        return null;
    }
    
    private String HCOship_id() {
        int number = new HyperionRandomizer(12).value;
        String ship_id;

        //Ship Randomizers
        switch (number) {
            case 0:
                return ship_id = "HS_Orionis_Confederacy";
            case 1:
                return ship_id = "HS_Naos_Confederacy";
            case 2:
                return ship_id = "HS_Atlas_Confederacy";
            case 3:
                return ship_id = "HS_Buffalo_Confederacy";
            case 4:
                return ship_id = "HS_Gemini_Confederacy";
            case 5:
                return ship_id = "HS_Alycone_Confederacy";
            case 6:
                return ship_id = "HS_Bellatrix_Confederacy";
            case 7:
                return ship_id = "HS_Carinae_Confederacy";
            case 8:
                return ship_id = "HS_Sirius_Confederacy";
            case 9:
                return ship_id = "HS_Eridani_Confederacy";
            case 10:
                return ship_id = "HS_Cassiopeia_Confederacy";
            case 11:
                return ship_id = "HS_Perseus_Confederacy";
            case 12:
                return ship_id = "HS_Valkyrie_Confederacy";
            default:
                break;
        }
        return null;
    }
    
    // Gets what star type and returns habitable zone min orbit
    private float starHabitableMin(PlanetAPI star) {
        float starRadius = star.getRadius();
        float starCoronaRadius = star.getSpec().getCoronaSize();
        
        // Yellow Main Sequence
        if(star.getTypeId().equals(new Star().YELLOW) ||
                star.getTypeId().equals(new Star().YELLOW_US)) {
            return ((starRadius * 1.725f) + (starCoronaRadius / 2));
            
        // Red Giant
        } else if(star.getTypeId().equals(new Star().RED_GIANT)) {
                return ((starRadius * 2.3f) + (starCoronaRadius / 2));
            
        // Red Supergiant
        } else if(star.getTypeId().equals(new Star().RED_SUPERGIANT)) {
                return ((starRadius * 4.6f) + (starCoronaRadius / 2));
                
        // Red Dwarf
        } else if(star.getTypeId().equals(new Star().RED_DWARF) ||
                star.getTypeId().equals(new Star().RED_DWARF_US)) {
            return ((starRadius * 1.05f) + (starCoronaRadius / 2));
        
        // Orange Main Sequence
        } else if(star.getTypeId().equals(new Star().ORANGE)) {
            return ((starRadius * 1.575f) + (starCoronaRadius / 2));
            
        // Orange Giant
        } else if(star.getTypeId().equals(new Star().ORANGE_GIANT) ||
                star.getTypeId().equals(new Star().ORANGE_GIANT_US)) {
            return ((starRadius * 3.15f) + (starCoronaRadius / 2));

        // Blue Giant
        } else if(star.getTypeId().equals(new Star().BLUE_GIANT) ||
                star.getTypeId().equals(new Star().BLUE_GIANT_US)) {
            return ((starRadius * 5.175f) + (starCoronaRadius / 2));
            
        // Blue Supergiant
        } else if(star.getTypeId().equals(new Star().BLUE_SUPERGIANT)) {
            return ((starRadius * 10.35f) + (starCoronaRadius / 2));
        
        // White Dwarf
        } else if(star.getTypeId().equals(new Star().WHITE_DWARF) ||
                star.getTypeId().equals(new Star().WHITE_DWARF_US)) {
            return ((starRadius * 1.725f) + (starCoronaRadius / 2));
        
        // Brown Dwarf
        } else if(star.getTypeId().equals(new Star().BROWN_DWARF) ||
                star.getTypeId().equals(new Star().BROWN_DWARF_US)) {
            return ((starRadius * 1.015f) + (starCoronaRadius / 2));
        
        // Neutron Star
        } else if(star.getTypeId().equals(new Star().NEUTRON_STAR)) {
            return starRadius * 10;
        
        // Black Hole
        } else if(star.getTypeId().equals(new Star().BLACK_HOLE)) {
            return 0;
            
        // Nebula Young
        } else if(star.getTypeId().equals(new Star().NEBULA_YOUNG)) {
                return 0;
                
        // Nebula Average
        } else if(star.getTypeId().equals(new Star().NEBULA_AVERAGE)) {
            return 0;

        // Nebula Old
        } else if(star.getTypeId().equals(new Star().NEBULA_OLD)) {
            return 0;
        }
        return 0;
    } 
}
